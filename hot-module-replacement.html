<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content=""><meta name=author content=""><title>hot module replacement</title><body><script src=js/doc.js charset=utf-8 async></script><div class=container><div class=row><div class=col-md-3><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div></div><div class=sidebar><p><a href=.>Home</a></p><p><a href=home.html>Home</a></p><h1>webpack</h1><ul><li><a href=webpack-getting-started.html>webpack Getting Started</a></li><li>Basics<ul><li><a href=commonjs.html>CommonJS</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-usage.html>webpack usage</a><ul><li><a href=webpack-detailed-usage.html>webpack detailed usage</a></li><li><a href=webpack-options.html>webpack options</a></li><li><a href=https://github.com/webpack/grunt-webpack>webpack with grunt</a></li><li><a href=webpack-plugins.html>webpack plugins</a></li></ul></li><li><a href=chunks.html>chunks</a></li><li><a href=resolving.html>resolving</a></li><li><a href=loaders.html>loaders</a></li><li><a href=loader-list.html>loader list</a></li><li><a href=require.context.html>require.context</a></li><li><a href=require.ensure.html>require.ensure</a></li><li><a href=webpack-dev-tools.html>webpack dev tools</a><ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li><li><a href=webpack-comparison.html>webpack comparison</a></li></ul></li><li>Advanced<ul><li><a href=writing-loaders.html>writing loaders</a></li><li><a href=require.include.html>require.include</a></li><li><a href=writing-webpack-plugins.html>writing webpack plugins</a></li><li><a href=optimizing.html>optimizing</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=webpack-runtime-api-summary.html>webpack runtime api summary</a></li></ul></li></ul><hr><ul><li><a href=changelog.html>changelog</a></li><li><a href=roadmap.html>roadmap</a></li><li><a href=ideas.html>ideas</a></li><li><a href=documentation-contributing.html>documentation contributing</a></li></ul></div></div><div class=col-md-9><div class=pull-right><a href=https://github.com/webpack/docs/wiki/hot-module-replacement/_edit id=wikieditlink>Edit</a></div><div class=row><div class=col-md-12><div class=page-header><h1 id=wikititle>hot module replacement</h1></div></div></div><div class=row><div id=wiki class=col-md-12><p>“Hot Module Replacement” (HMR) is an opt-in feature, so you need to put some code at chosen points of your application. The dependencies are handled by the module system.</p><p>I. e. you place your hot replacement code in module A. Module A requires module B and B requires C. If module C is updated, and module B cannot handle the update, modules B and C become outdated. Module A can handle the update and new modules B and C are injected.</p><h2><a class=anchor href=#example-1-hot-replace-request-handler-of-http-server id=example-1-hot-replace-request-handler-of-http-server><i class="glyphicon glyphicon-link"></i></a>Example 1: hot replace request handler of http server</h2><pre><code><span class=keyword>var</span> requestHandler = require(<span class=string>"./handler.js"</span>);
<span class=keyword>var</span> server = require(<span class=string>"http"</span>).createServer();
server.on(<span class=string>"request"</span>, requestHandler);
server.listen(<span class=number>8080</span>);

<span class=comment>// check if HMR is enabled</span>
<span class=keyword>if</span>(module.hot) {
  <span class=comment>// accept update of dependency</span>
  module.hot.accept(<span class=string>"./handler.js"</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>// replace request handler of server</span>
    server.removeListener(<span class=string>"request"</span>, requestHandler);
    requestHandler = require(<span class=string>"./handler.js"</span>);
    server.on(<span class=string>"request"</span>, requestHandler);
  });
}</code></pre><h2><a class=anchor href=#example-2-hot-replace-css id=example-2-hot-replace-css><i class="glyphicon glyphicon-link"></i></a>Example 2: hot replace css</h2><pre><code><span class=comment>// addStyleTag(css: string) =&gt; HTMLStyleElement</span>
<span class=keyword>var</span> addStyleTag = require(<span class=string>"./addStyleTag"</span>);

<span class=keyword>var</span> element = addStyleTag(<span class=string>".rule { attr: name }"</span>);
module.exports = <span class=literal>null</span>;

<span class=comment>// check if HMR is enabled</span>
<span class=keyword>if</span>(module.hot) {

  <span class=comment>// accept itself</span>
  module.hot.accept();

  <span class=comment>// removeStyleTag(element: HTMLStyleElement) =&gt; void</span>
  <span class=keyword>var</span> removeStyleTag = require(<span class=string>"./removeStyleTag"</span>);

  <span class=comment>// dispose handler</span>
  module.hot.dispose(<span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>// revoke the side effect</span>
    removeStyleTag(element);
  });
}</code></pre><h2><a class=anchor href=#api id=api><i class="glyphicon glyphicon-link"></i></a>API</h2><p>If HMR is enabled for a module <code>module.hot</code> is an object containing these properties:</p><h3><a class=anchor href=#accept-dependencies-string-callback-updateddependencies-void-void id=accept-dependencies-string-callback-updateddependencies-void-void><i class="glyphicon glyphicon-link"></i></a><code>accept(dependencies: string[], callback: (updatedDependencies) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>Accept code updates for the specified dependencies. The callback is called when dependencies were replaced.</p><h3><a class=anchor href=#accept-dependency-string-callback-void-void id=accept-dependency-string-callback-void-void><i class="glyphicon glyphicon-link"></i></a><code>accept(dependency: string, callback: () =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>See above.</p><h3><a class=anchor href=#accept-void id=accept-void><i class="glyphicon glyphicon-link"></i></a><code>accept() =&gt; <span class=keyword>void</span></code></h3><p>Accept code updates for this module without notification of parents. This should only be used if the module doesn’t export anything.</p><h3><a class=anchor href=#decline-dependencies-string-void id=decline-dependencies-string-void><i class="glyphicon glyphicon-link"></i></a><code>decline(dependencies: string[]) =&gt; <span class=keyword>void</span></code></h3><p>Do not accept updates for the specified dependencies. If any dependencies is updated, the code update fails with code <code><span class=string>"decline"</span></code>.</p><h3><a class=anchor href=#decline-dependency-string-void id=decline-dependency-string-void><i class="glyphicon glyphicon-link"></i></a><code>decline(dependency: string) =&gt; <span class=keyword>void</span></code></h3><p>See above.</p><h3><a class=anchor href=#decline-void id=decline-void><i class="glyphicon glyphicon-link"></i></a><code>decline() =&gt; <span class=keyword>void</span></code></h3><p>Flag the current module as not updateable. If updated the update code would fail with code <code><span class=string>"decline"</span></code>.</p><h3><a class=anchor href=#dispose-adddisposehandler-callback-data-object-void-void id=dispose-adddisposehandler-callback-data-object-void-void><i class="glyphicon glyphicon-link"></i></a><code>dispose/addDisposeHandler(callback: (data: object) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>Add a one time handler, which is executed when the current module code is replaced. Here you should destroy/remove any persistent resource you have claimed/created. If you want to transfer state to the new module, add it to <code>data</code> object. The <code>data</code> will be available at <code>module.hot.data</code> on the new module.</p><h3><a class=anchor href=#removedisposehandler-callback-data-object-void-void id=removedisposehandler-callback-data-object-void-void><i class="glyphicon glyphicon-link"></i></a><code>removeDisposeHandler(callback: (data: object) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>Remove a handler.</p><p>This can useful to add a temporary dispose handler. You could i. e. replace code while in the middle of a multi-step async function.</p><h2><a class=anchor href=#management-api id=management-api><i class="glyphicon glyphicon-link"></i></a>Management API</h2><p>Also on the <code>module.hot</code> object.</p><h3><a class=anchor href=#setapplyonupdate-flag-boolean-void id=setapplyonupdate-flag-boolean-void><i class="glyphicon glyphicon-link"></i></a><code>setApplyOnUpdate(flag: boolean) =&gt; <span class=keyword>void</span></code></h3><p><code>flag == <span class=literal>false</span></code> means you have to have to manually call <code>apply()</code> if an update is ready.</p><p><code>flag == <span class=literal>true</span></code> means that it is called for you.</p><p>Default should be <code><span class=literal>true</span></code>.</p><h3><a class=anchor href=#check-callback-err-error-outdatedmodules-module-void id=check-callback-err-error-outdatedmodules-module-void><i class="glyphicon glyphicon-link"></i></a><code>check(callback: (err: Error, outdatedModules: Module[]) =&gt; <span class=keyword>void</span></code></h3><p>Throws an exceptions if <code>status()</code> is not <code>idle</code>.</p><p>Check all currently loaded modules for updates and apply updates if found.</p><p>If no update where found, the callback is called with <code><span class=literal>null</span></code>.</p><p>If applyOnUpdate is set the callback will be called with all modules that were disposed.</p><p>If applyOnUpdate is not set the callback will be called with all modules that will be disposed on <code>apply()</code>.</p><h3><a class=anchor href=#apply-callback-err-error-outdatedmodules-module-void id=apply-callback-err-error-outdatedmodules-module-void><i class="glyphicon glyphicon-link"></i></a><code>apply(callback: (err: Error, outdatedModules: Module[]) =&gt; <span class=keyword>void</span></code></h3><p>If <code>status() != <span class=string>"ready"</span></code> it throws an error.</p><p>Continue the update process.</p><h3><a class=anchor href=#status-string id=status-string><i class="glyphicon glyphicon-link"></i></a><code>status() =&gt; string</code></h3><p>Return one of <code>idle</code>, <code>check</code>, <code>watch</code>, <code>watch-delay</code>, <code>prepare</code>, <code>ready</code>, <code>dispose</code>, <code>apply</code>, <code>abort</code> or <code>fail</code>.</p><p><code>idle</code></p><p>The HMR is waiting for your call the <code>check()</code>. When you call it the status will change to <code>check</code>.</p><p><code>check</code></p><p>The HMR is checking for updates. If it doesn’t find updates it will change back to <code>idle</code>.</p><p>If updates where found it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>idle</code>.</p><p><code>watch</code></p><p>The HMR is in watch mode and will automatically be notified about changes. After the first change it will change to <code>watch-delay</code> and wait for a specified time to start the update process. Any change will reset the timeout, to accumulate more changes. When the update process is started it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>watch</code> or <code>watch-delay</code> if changes where detected while updating.</p><p><code>prepare</code></p><p>The HMR is prepare stuff for the update. This may means that it’s downloading something.</p><p><code>ready</code></p><p>An update is available and prepared. Call <code>apply()</code> to continue.</p><p><code>dispose</code></p><p>The HMR is calling the dispose handlers of modules that will be replaced.</p><p><code>apply</code></p><p>The HMR is calling the accept handlers of the parents of replaced modules, than it requires the self accepted modules.</p><p><code>abort</code></p><p>A update cannot apply, but the system is still in a (old) consistent state.</p><p><code>fail</code></p><p>A update has thrown an exception in the middle of the process, and the system is (maybe) in a inconsistent state. The system should be restarted.</p><h3><a class=anchor href=#status-addstatushandler-callback-status-string-void-void id=status-addstatushandler-callback-status-string-void-void><i class="glyphicon glyphicon-link"></i></a><code>status/addStatusHandler(callback: (status: string) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>Register a callback on status change.</p><h3><a class=anchor href=#removestatushandler-callback-status-string-void-void id=removestatushandler-callback-status-string-void-void><i class="glyphicon glyphicon-link"></i></a><code>removeStatusHandler(callback: (status: string) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></h3><p>Remove a registered status change handler.</p><h2><a class=anchor href=#how-to-care-with id=how-to-care-with><i class="glyphicon glyphicon-link"></i></a>How to care with …</h2><h3><a class=anchor href=#a-module-without-side-effects-the-standard-case id=a-module-without-side-effects-the-standard-case><i class="glyphicon glyphicon-link"></i></a>… a module without side effects (the standard case)</h3><p>Nothing to do in the module. Any parent can accept it.</p><h3><a class=anchor href=#a-module-with-side-effects id=a-module-with-side-effects><i class="glyphicon glyphicon-link"></i></a>… a module with side effects</h3><p>The module needs a dispose handler, than any parent can accept it.</p><h3><a class=anchor href=#a-module-with-only-side-effects-and-no-exports id=a-module-with-only-side-effects-and-no-exports><i class="glyphicon glyphicon-link"></i></a>… a module with only side effects and no exports</h3><p>The module needs a dispose handler and can accept itself. No action is required in the parent.</p><p>If the module’s code is not in your hand, the parent can accept the module with some custom dispose logic.</p><h3><a class=anchor href=#the-application-entry-module id=the-application-entry-module><i class="glyphicon glyphicon-link"></i></a>… the application entry module</h3><p>As it doesn’t export it can accept itself. A dispose handler can pass the application state on replacement.</p><h3><a class=anchor href=#external-module-with-not-handleable-side-effects id=external-module-with-not-handleable-side-effects><i class="glyphicon glyphicon-link"></i></a>… external module with not handleable side effects</h3><p>In the nearest parent you decline the dependency. This makes your application throw on update. But as it’s an external module, an update is very rar.</p></div></div></div></div></div><a href=https://github.com/webpack/webpack><img style="position: absolute; top: 0; left: 0; border: 0" src=https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png alt="Fork me on GitHub"></a>