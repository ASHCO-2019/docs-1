<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content=""><meta name=author content=""><title>optimizing</title><body><div class=container><div class=row><div class=col-md-3><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div></div><div id=sidebar class=sidebar><p><a href=home.html>Home</a></p><h1>webpack</h1><ul><li><a href=webpack-getting-started.html>webpack Getting Started</a></li><li>Basic<ul><li><a href=commonjs.html>CommonJS</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-usage.html>webpack usage</a><ul><li><a href=webpack-detailed-usage.html>webpack detailed usage</a></li><li><a href=webpack-options.html>webpack options</a></li><li><a href=https://github.com/webpack/grunt-webpack>webpack with grunt</a></li><li><a href=webpack-plugins.html>webpack plugins</a></li></ul></li><li><a href=chunks.html>chunks</a></li><li><a href=resolving.html>resolving</a></li><li><a href=loaders.html>loaders</a></li><li><a href=loader-list.html>loader list</a></li><li><a href=require.context.html>require.context</a></li><li><a href=require.ensure.html>require.ensure</a></li><li><a href=webpack-dev-tools.html>webpack dev tools</a><ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li><li><a href=webpack-comparison.html>webpack comparison</a></li></ul></li><li>Advanced<ul><li><a href=writing-loaders.html>writing loaders</a></li><li><a href=require.include.html>require.include</a></li><li><a href=writing-webpack-plugins.html>writing webpack plugins</a></li><li><a href=optimizing.html>optimizing</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=webpack-runtime-api-summary.html>webpack runtime api summary</a></li></ul></li></ul><h1>enhanced-require</h1><p>Coming soon…</p></div></div><div class=col-md-9><div class=row><div class=col-md-12><div class=pull-right><a href=https://github.com/webpack/docs/wiki/optimizing/_edit id=wikieditlink>Edit</a></div><div class=page-header><h1 id=wikititle>optimizing</h1></div></div></div><div class=row><div id=wiki class=col-md-12><h1><a class=anchor href=#optimizing id=optimizing><i class="glyphicon glyphicon-link"></i></a>optimizing</h1><h2><a class=anchor href=#minimize id=minimize><i class="glyphicon glyphicon-link"></i></a>Minimize</h2><p>To minimize your scripts (and your css, if you use the css-loader) webpack supports a simple option:</p><p><code>--optimize-minimize</code> resp. <code>optimize: { minimize: <span class=literal>true</span> }</code></p><p>That’s a pretty simply but effective way to optimize your web app.</p><p>As you already know (if you’ve read the remaining docs) webpack give your modules and chunks ids to identify them. Webpack can vary the distribution of the ids to get the smallest id length for often used ids with a simple option:</p><p><code>--optimize-occurence-order</code> resp. <code>optimize: { occurenceOrder: <span class=literal>true</span> }</code></p><p>The entry chunks have higher priority for file size.</p><h2><a class=anchor href=#deduplication id=deduplication><i class="glyphicon glyphicon-link"></i></a>Deduplication</h2><p>If you use some libraries with cool dependency trees, it may occur that some files are identical. Webpack can find these files and deduplicate them. This prevent to include duplicate code into your bundle and instead copy the function at runtime. It doesn’t affect semantics. You can enable it with:</p><p><code>--optimize-dedupe</code> resp. <code>optimize: { dedupe: <span class=literal>true</span> }</code></p><p>The feature add some overhead to the entry chunk.</p><h2><a class=anchor href=#caching id=caching><i class="glyphicon glyphicon-link"></i></a>Caching</h2><p>To effectively cache your files, they should have a hash or version in their url. You can emit or move the output files manually in a folder called <code>v1<span class=number>.3</span></code>. But this has several disadvantages: Extra work for the developer and not changed files are not loaded from cache.</p><p>Webpack can add hashes for the files to the filename. Loaders that emit files (worker-loader, file-loader) already do this. For the chunks you have to enable it. There a two levels:</p><ol><li>Compute a hash of all chunks and add it.</li><li>Compute a hash per chunk and add it.</li></ol><p>Option 1 is enabled by adding <code>[hash]</code> to the filename config options</p><p><code>webpack .<span class=regexp>/entry output.[hash].bundle.js</span></code></p><pre><code>{
  <span class=attribute>output</span>: {
    <span class=attribute>path</span>: path.join(__dirname, <span class=string>"assets"</span>, <span class=string>"[hash]"</span>),
    <span class=attribute>publicPath</span>: <span class=string>"assets/[hash]/"</span>,
    <span class=attribute>filename</span>: <span class=string>"output.[hash].bundle.js"</span>,
    <span class=attribute>chunkFilename</span>: <span class=string>"[id].[hash].bundle.js"</span>
  }
}</code></pre><p>Option 2 is enabled by adding <code>[chunkhash]</code> to the chunk filename config option</p><p><code>--output-chunk-file [chunkhash].js</code></p><p><code>output: { chunkFilename: <span class=string>"[chunkhash].bundle.js"</span> }</code></p><p>Note that you need to reference the entry chunk with it’s hash in your HTML. You may want to extract the hash or the filename from the stats.</p><p>In combination with Hot Code Replacement your must use option 1, but not on the <code>publicPath</code> config option.</p><h2><a class=anchor href=#chunks id=chunks><i class="glyphicon glyphicon-link"></i></a>Chunks</h2><p>While writing your code you have already added many code split points to load stuff on demand. After compiling you may notice that there are too many of them and your chunks are so small that the HTTP overhead is big. That’s no problem. Webpack can postprocess your chunks by merging them cleverly. You can provide two options:</p><ul><li>Limit the maximum chunk count with <code>--optimize-max-chunks <span class=number>15</span></code> <code>optimize: { maxChunks: <span class=number>15</span> }</code></li><li>Limit the minimum chunk size with <code>--optimize-min-chunk-size <span class=number>10000</span></code> <code>optimize: { minChunkSize: <span class=number>10000</span> }</code></li></ul><p>Webpack will take care of it by merging chunks (It will prefer merging chunk which have duplicate modules). Nothing will be merged into the entry chunk to not impact initial page loading time.</p><h2><a class=anchor href=#single-page-app id=single-page-app><i class="glyphicon glyphicon-link"></i></a>Single-Page-App</h2><p>A Single-Page-App is the web app type webpack is designed and optimized for.</p><p>You may have aplit the app into multiple chunks, which are loaded at your router. The entry chunk only contains the router and some libraries, but no content. This works great while your user is navigating through your app, but for initial page load you need 2 round trips: One for the router and one for the current content page.</p><p>If you use the HTML5 History API to reflect the current content page in the URL, your server can know which content page will be requested by the client code. To save round trips the server can include the content chunk in the response: This is possible by just adding it as script tag. The browser will load both chunks parallel.</p><pre><code><span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"entry-chunk.js"</span> <span class=attribute>type</span>=<span class=value>"text/javascript"</span> <span class=attribute>charset</span>=<span class=value>"utf-8"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span>
<span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"3.chunk.js"</span> <span class=attribute>type</span>=<span class=value>"text/javascript"</span> <span class=attribute>charset</span>=<span class=value>"utf-8"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span></code></pre><p>You can extract the chunk filename from the stats.</p><h2><a class=anchor href=#multi-page-app id=multi-page-app><i class="glyphicon glyphicon-link"></i></a>Multi-Page-App</h2><p>When you compile a (real) multi page app, you want to share common code between the pages. In fact this is really easy with webpack: Just compile with multiple entry points:</p><p><code>webpack p1=.<span class=regexp>/page1 p2=./</span>page2 p3=.<span class=regexp>/page3 [name].entry-chunk.js</span></code></p><pre><code>module.exports = {
  entry: {
    p1: <span class=string>"./page1"</span>,
    p2: <span class=string>"./page2"</span>,
    p3: <span class=string>"./page3"</span>
  },
  output: {
    filename: <span class=string>"[name].entry.chunk.js"</span>
  }
}</code></pre><p>This will generate multiple entry chunks: <code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> and <code>p3.entry.chunk.js</code>. But additional chunks can be shared by them.</p><p>If your entry chunks have some modules in common, there is a cool plugin for this. The <code>CommonsChunkPlugin</code> identifies common modules and put them into a commons chunk. You need to add two script tags to your page, one for the commons chunk and one for the entry chunk.</p><pre><code><span class=keyword>var</span> CommonsChunkPlugin = require(<span class=string>"webpack/lib/optimize/CommonsChunkPlugin"</span>);
module.exports = {
  entry: {
    p1: <span class=string>"./page1"</span>,
    p2: <span class=string>"./page2"</span>,
    p3: <span class=string>"./page3"</span>
  },
  output: {
    filename: <span class=string>"[name].entry.chunk.js"</span>
  },
  plugins: [
    <span class=keyword>new</span> CommonsChunkPlugin(<span class=string>"commons.chunk.js"</span>)
  ]
}</code></pre><p>This will generate multiple entry chunks: <code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> and <code>p3.entry.chunk.js</code>, plus one <code>commons.chunk.js</code>. Frist load <code>commons.chunk.js</code> and than one of the <code>xx.entry.chunk.js</code>.</p><p>You can generate multiple commons chunks, by selecting the entry chunks. And you can nest commons chunks.</p><pre><code><span class=keyword>var</span> CommonsChunkPlugin = require(<span class=string>"webpack/lib/optimize/CommonsChunkPlugin"</span>);
module.exports = {
  entry: {
    p1: <span class=string>"./page1"</span>,
    p2: <span class=string>"./page2"</span>,
    p3: <span class=string>"./page3"</span>,
    ap1: <span class=string>"./admin/page1"</span>,
    ap2: <span class=string>"./admin/page2"</span>
  },
  output: {
    filename: <span class=string>"[name].js"</span>
  },
  plugins: [
    <span class=keyword>new</span> CommonsChunkPlugin(<span class=string>"admin-commons.js"</span>, [<span class=string>"ap1"</span>, <span class=string>"ap2"</span>]),
    <span class=keyword>new</span> CommonsChunkPlugin(<span class=string>"commons.js"</span>, [<span class=string>"p1"</span>, <span class=string>"p2"</span>, <span class=string>"admin-commons.js"</span>])
  ]
};
<span class=comment>// &lt;script&gt;s required:</span>
<span class=comment>// page1.html: commons.js, p1.js</span>
<span class=comment>// page2.html: commons.js, p2.js</span>
<span class=comment>// page3.html: p3.js</span>
<span class=comment>// admin-page1.html: commons.js, admin-commons.js, ap1.js</span>
<span class=comment>// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></code></pre></div></div></div></div></div><script src=js/doc.js charset=utf-8></script>