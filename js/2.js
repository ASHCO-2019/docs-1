webpackJsonp([2],{13:function(module,exports,require){eval('module.exports = function downloadWiki(wiki, callback) {\r\n	var request = new XMLHttpRequest();\r\n	request.open("GET", "http://github-wiki.herokuapp.com/webpack/docs/" + wiki, true);\r\n	request.onreadystatechange = function() {\r\n		if(request.readyState === 4) {\r\n			if(request.status !== 200) {\r\n				return callback(new Error("Statuscode is " + request.status));\r\n			} else {\r\n				return callback(null, request.responseText);\r\n			}\r\n		}\r\n	};\r\n	request.send(null);\r\n};\n\n// WEBPACK FOOTER\n// module.id = 13\n// module.readableIdentifier = ./app/downloadWiki.js\n//@ sourceURL=webpack-module:///./app/downloadWiki.js')},33:function(module,exports,require){eval("module.exports = function extractRegExpFromText(text, regExp, postprocessFn) {\r\n	var array = [];\r\n\r\n	var match;\r\n	while(match = regExp.exec(text)) {\r\n		var link = postprocessFn(match[1]);\r\n		if(array.indexOf(link) < 0)\r\n			array.push(link);\r\n	}\r\n\r\n	return array;\r\n}\r\n\n\n// WEBPACK FOOTER\n// module.id = 33\n// module.readableIdentifier = ./lib/extractRegExpFromText.js\n//@ sourceURL=webpack-module:///./lib/extractRegExpFromText.js")},35:function(module,exports,require){eval("var extractRegExpFromText = require(33);\r\nvar Searcher = require(37);\r\n\r\nfunction FullTextSearcher(searchString) {\r\n	this.fuseSearchers = this.tokenize(searchString).map(function(item) {\r\n		return new Searcher(item, {\r\n			distance: item.length * 10,\r\n			threshold: 0.8\r\n		});\r\n	});\r\n}\r\n\r\nmodule.exports = FullTextSearcher;\r\n\r\nFullTextSearcher.prototype.scanDocument = function(title, md) {\r\n	title = this.tokenize(title);\r\n	md = this.tokenize(md);\r\n	var scores = this.fuseSearchers.map(function() { return 0 });\r\n	scoreItems(title, this.fuseSearchers);\r\n	scores = scores.map(function(s) { return s*10; });\r\n	scoreItems(md, this.fuseSearchers);\r\n	return {\r\n		score: scores.reduce(function(a, b) { return a + b; }, 0) *\r\n			scores.map(function(s) { return s; }, this).reduce(function(a, b) { return Math.min(a, b); }),\r\n		scores: scores\r\n	};\r\n\r\n	function scoreItems(items, fuseSearchers) {\r\n		items.forEach(function(item) {\r\n			fuseSearchers.forEach(function(searcher, idx) {\r\n				var result = searcher.search(item);\r\n				if(result.isMatch) {\r\n					scores[idx] += (1 - result.score) / items.length;\r\n				}\r\n			});\r\n		});\r\n	}\r\n}\r\n\r\nFullTextSearcher.prototype.tokenize = function(str) {\r\n	return extractRegExpFromText(str, /([\\w\\d\\-\\_\\.]+)/gi, function(s) { return s; });\r\n};\n\n// WEBPACK FOOTER\n// module.id = 35\n// module.readableIdentifier = ./app/FullTextSearcher.js\n//@ sourceURL=webpack-module:///./app/FullTextSearcher.js")},37:function(module,exports,require){eval("/**\r\n * Fuse - Lightweight fuzzy-search\r\n *\r\n * Copyright (c) 2012 Kirollos Risk <kirollos@gmail.com>.\r\n * All Rights Reserved. Apache Software License 2.0\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n \r\n /**\r\n * Adapted from \"Diff, Match and Patch\", by Google\r\n *\r\n *   http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Modified by: Kirollos Risk <kirollos@gmail.com>\r\n * -----------------------------------------------\r\n * Details: the algorithm and structure was modified to allow the creation of\r\n * <Searcher> instances with a <search> method inside which does the actual\r\n * bitap search. The <pattern> (the string that is searched for) is only defined\r\n * once per instance and thus it eliminates redundant re-creation when searching\r\n * over a list of strings.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n */\r\nfunction Searcher(pattern, options) {\r\n	options = options || {};\r\n\r\n	// Aproximately where in the text is the pattern expected to be found?\r\n	var MATCH_LOCATION = options.location || 0,\r\n\r\n		// Determines how close the match must be to the fuzzy location (specified above).\r\n		// An exact letter match which is 'distance' characters away from the fuzzy location\r\n		// would score as a complete mismatch. A distance of '0' requires the match be at\r\n		// the exact location specified, a threshold of '1000' would require a perfect match\r\n		// to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\r\n		MATCH_DISTANCE = options.distance || 100,\r\n\r\n		// At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\r\n		// (of both letters and location), a threshold of '1.0' would match anything.\r\n		MATCH_THRESHOLD = options.threshold || 0.6,\r\n\r\n\r\n		pattern = options.caseSensitive ? pattern : pattern.toLowerCase(),\r\n		patternLen = pattern.length;\r\n\r\n	if (patternLen > 32) {\r\n		throw new Error('Pattern length is too long');\r\n	}\r\n\r\n	var matchmask = 1 << (patternLen - 1);\r\n\r\n	/**\r\n	 * Initialise the alphabet for the Bitap algorithm.\r\n	 * @return {Object} Hash of character locations.\r\n	 * @private\r\n	 */\r\n	var pattern_alphabet = (function () {\r\n		var mask = {},\r\n			i = 0;\r\n\r\n		for (i = 0; i < patternLen; i++) {\r\n			mask[pattern.charAt(i)] = 0;\r\n		}\r\n\r\n		for (i = 0; i < patternLen; i++) {\r\n			mask[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n		}\r\n\r\n		return mask;\r\n	})();\r\n\r\n	/**\r\n	 * Compute and return the score for a match with <e> errors and <x? location.\r\n	 * @param {number} e Number of errors in match.\r\n	 * @param {number} x Location of match.\r\n	 * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n	 * @private\r\n	 */\r\n	function match_bitapScore(e, x) {\r\n		var accuracy = e / patternLen,\r\n			proximity = Math.abs(MATCH_LOCATION - x);\r\n\r\n		if (!MATCH_DISTANCE) {\r\n			// Dodge divide by zero error.\r\n			return proximity ? 1.0 : accuracy;\r\n		}\r\n		return accuracy + (proximity / MATCH_DISTANCE);\r\n	}\r\n\r\n	/**\r\n	 * Compute and return the result of the search\r\n	 * @param {String} text The text to search in\r\n	 * @return\r\n	 *     {Object} Literal containing:\r\n	 *     {Boolean} isMatch Whether the text is a match or not\r\n	 *     {Decimal} score Overal score for the match\r\n	 * @public\r\n	 */\r\n	this.search = function (text) {\r\n		text = options.caseSensitive ? text : text.toLowerCase();\r\n\r\n		if (pattern === text) {\r\n			// Exact match\r\n			return {\r\n				isMatch: true,\r\n				score: 0\r\n			};\r\n		}\r\n\r\n		var i, j,\r\n			// Set starting location at beginning text and initialise the alphabet.\r\n			textLen = text.length,\r\n			// Highest score beyond which we give up.\r\n			scoreThreshold = MATCH_THRESHOLD,\r\n			// Is there a nearby exact match? (speedup)\r\n			bestLoc = text.indexOf(pattern, MATCH_LOCATION),\r\n\r\n			binMin, binMid,\r\n			binMax = patternLen + textLen,\r\n\r\n			lastRd, start, finish, rd, charMatch,\r\n\r\n			score = 1,\r\n\r\n			locations = [];\r\n\r\n		if (bestLoc != -1) {\r\n			scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\r\n			// What about in the other direction? (speedup)\r\n			bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\r\n\r\n			if (bestLoc != -1) {\r\n				scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\r\n			}\r\n		}\r\n\r\n		bestLoc = -1;\r\n\r\n		for (i = 0; i < patternLen; i++) {\r\n			// Scan for the best match; each iteration allows for one more error.\r\n			// Run a binary search to determine how far from 'MATCH_LOCATION' we can stray at this\r\n			// error level.\r\n			binMin = 0;\r\n			binMid = binMax;\r\n			while (binMin < binMid) {\r\n				if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\r\n					binMin = binMid;\r\n				} else {\r\n					binMax = binMid;\r\n				}\r\n				binMid = Math.floor((binMax - binMin) / 2 + binMin);\r\n			}\r\n\r\n			// Use the result from this iteration as the maximum for the next.\r\n			binMax = binMid;\r\n			start = Math.max(1, MATCH_LOCATION - binMid + 1);\r\n			finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\r\n\r\n			// Initialize the bit array\r\n			rd = Array(finish + 2);\r\n\r\n			rd[finish + 1] = (1 << i) - 1;\r\n\r\n			for (j = finish; j >= start; j--) {\r\n				// The alphabet <pattern_alphabet> is a sparse hash, so the following line generates warnings.\r\n				charMatch = pattern_alphabet[text.charAt(j - 1)];\r\n				if (i === 0) {\r\n					// First pass: exact match.\r\n					rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n				} else {\r\n					// Subsequent passes: fuzzy match.\r\n					rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];\r\n				}\r\n				if (rd[j] & matchmask) {\r\n					score = match_bitapScore(i, j - 1);\r\n					// This match will almost certainly be better than any existing match.\r\n					// But check anyway.\r\n					if (score <= scoreThreshold) {\r\n						// Told you so.\r\n						scoreThreshold = score;\r\n						bestLoc = j - 1;\r\n						locations.push(bestLoc);\r\n\r\n						if (bestLoc > MATCH_LOCATION) {\r\n							// When passing loc, don't exceed our current distance from loc.\r\n							start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\r\n						} else {\r\n							// Already passed loc, downhill from here on in.\r\n							break;\r\n						}\r\n					}\r\n				}\r\n			}\r\n			// No hope for a (better) match at greater error levels.\r\n			if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\r\n				break;\r\n			}\r\n			lastRd = rd;\r\n		}\r\n\r\n		return {\r\n			isMatch: bestLoc >= 0,\r\n			score: score\r\n		};\r\n\r\n	}\r\n}\r\n\r\nmodule.exports = Searcher;\n\n// WEBPACK FOOTER\n// module.id = 37\n// module.readableIdentifier = ./lib/fuse.js/Searcher.js\n//@ sourceURL=webpack-module:///./lib/fuse.js/Searcher.js")}});