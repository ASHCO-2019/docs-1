webpackJsonp([1],{16:function(module,exports,require){eval('module.exports = function titleToLink(title) {\r\n	if(!title) return title;\r\n	return title.replace(/[ _]/g, "-").toLowerCase();\r\n}\r\n\n\n// WEBPACK FOOTER\n// module.id = 16\n// module.readableIdentifier = ./lib/titleToLink.js\n//@ sourceURL=webpack-module:///./lib/titleToLink.js')},33:function(module,exports,require){eval('var marked = require(44);\r\nvar titleToLink = require(16);\r\nvar hljs = require(39);\r\n\r\nfunction unescape(html) {\r\n	return html\r\n		.replace(/&#39;/g, "\'")\r\n		.replace(/&quot;/g, \'"\')\r\n		.replace(/&gt;/g, \'>\')\r\n		.replace(/&lt;/g, \'<\')\r\n		.replace(/&amp;/g, \'&\');\r\n}\r\n\r\nfunction escape(html) {\r\n	return html\r\n		.replace(/&/g, "&amp;")\r\n		.replace(/</g, "&lt;")\r\n		.replace(/>/g, "&gt;")\r\n		.replace(/"/g, "&quot;")\r\n		.replace(/\'/g, "&#39;");\r\n}\r\n\r\nmodule.exports = function renderMarkdown(md, noRefs) {\r\n	md = md.replace(/\\[\\[([^\\]]+?)\\s*\\|\\s*([a-z0-9 \\-_\\.]+)\\]\\]/gi, function(intraLink) {\r\n		// [[text | intra link]]\r\n		var match = /\\[\\[([^\\]]+?)\\s*\\|\\s*([a-z0-9 \\-_\\.]+)\\]\\]/gi.exec(intraLink);\r\n		var link = titleToLink(match[2]);\r\n		return "[" + match[1] + "](" + link + ".html)";\r\n	}).replace(/\\[\\[([a-z0-9 \\-_\\.]+)\\]\\]/gi, function(intraLink) {\r\n		// [[intra link]]\r\n		var match = /\\[\\[(.+)\\]\\]/gi.exec(intraLink);\r\n		var link = titleToLink(match[1]);\r\n		return "[" + match[1] + "](" + link + ".html)";\r\n	});\r\n	var listOfHeadings = [];\r\n	var renderer = new marked.Renderer();\r\n	renderer.code = function(code, lang) {\r\n		var html = false;\r\n		if(lang === "html") lang = "xml";\r\n		try {\r\n			if(lang) html = hljs.highlight(lang, code).value;\r\n			else html = hljs.highlightAuto(code).value;\r\n		} catch(e) {\r\n			html = escape(code);\r\n		}\r\n		return "<pre><code>" + html + "</code></pre>";\r\n	};\r\n	renderer.codespan = function(code) {\r\n		code = unescape(code);\r\n		var html = hljs.highlight("javascript", code).value;\r\n		return "<code>" + html + "</code>";\r\n	};\r\n	renderer.heading = function(text, level, raw, options) {\r\n		if(noRefs) {\r\n			return \'<h\'\r\n				+ level\r\n				+ \'>\'\r\n				+ text\r\n				+ \'</h\'\r\n				+ level\r\n				+ \'>\\n\';\r\n		} else {\r\n			var anchor = raw.toLowerCase().trim().replace(/[^\\w]+/g, \'-\').replace(/^\\-+|\\-+$/g, "");\r\n			listOfHeadings.push({\r\n				anchor: anchor,\r\n				text: text,\r\n				level: level\r\n			});\r\n			return \'<h\'\r\n				+ level\r\n				+ \' id="\'\r\n				+ anchor\r\n				+ \'"><a class="anchor" href="#\'\r\n				+ anchor\r\n				+ \'"><i class="glyphicon glyphicon-link"></i></a>\'\r\n				+ text\r\n				+ \'</h\'\r\n				+ level\r\n				+ \'>\\n\';\r\n		}\r\n	};\r\n	renderer.table = function(header, body) {\r\n		return \'<table class="table table-bordered table-striped table-hover">\\n\'\r\n			+ \'<thead>\\n\'\r\n			+ header\r\n			+ \'</thead>\\n\'\r\n			+ \'<tbody>\\n\'\r\n			+ body\r\n			+ \'</tbody>\\n\'\r\n			+ \'</table>\\n\';\r\n	};\r\n	var html = marked(md, {\r\n		renderer: renderer,\r\n		gfm: true,\r\n		tables: true,\r\n		breaks: false,\r\n		smartLists: true,\r\n		smartypants: true\r\n	});\r\n	var contents = [];\r\n	var currentLevel = listOfHeadings.map(function(h) {\r\n		return h.level;\r\n	}).reduce(function(a, b) { return Math.min(a, b); }, 1000) - 1;\r\n	listOfHeadings.forEach(function(heading) {\r\n		if(currentLevel === heading.level) {\r\n			contents.push("</li><li>");\r\n		} else if(currentLevel < heading.level - 1) {\r\n			return;\r\n		} else if(currentLevel < heading.level) {\r\n			contents.push("<ul><li>");\r\n			currentLevel++;\r\n		} else if(currentLevel > heading.level) {\r\n			while(currentLevel > heading.level) {\r\n				contents.push("</li></ul>");\r\n				currentLevel--;\r\n			}\r\n			contents.push("</li><li>");\r\n		}\r\n		contents.push("<a href=\\"#",\r\n			heading.anchor,\r\n			"\\">",\r\n			heading.text,\r\n			"</a>");\r\n	});\r\n	while(listOfHeadings.length > 0 && currentLevel > 0) {\r\n		contents.push("</li></ul>");\r\n		currentLevel--;\r\n	}\r\n	contents = contents.join("");\r\n	if(contents) {\r\n		return "<div class=\\"contents\\">" + contents + "</div>" + html;\r\n	}\r\n	return html;\r\n}\r\n\n\n// WEBPACK FOOTER\n// module.id = 33\n// module.readableIdentifier = ./lib/renderMarkdown.js\n//@ sourceURL=webpack-module:///./lib/renderMarkdown.js')},37:function(module,exports,require){eval("module.exports = function(hljs) {\r\n  var KEYWORDS = {\r\n    keyword:\r\n      // JS keywords\r\n      'in if for while finally new do return else break catch instanceof throw try this ' +\r\n      'switch continue typeof delete debugger super ' +\r\n      // Coffee keywords\r\n      'then unless until loop of by when and or is isnt not',\r\n    literal:\r\n      // JS literals\r\n      'true false null undefined ' +\r\n      // Coffee literals\r\n      'yes no on off',\r\n    reserved:\r\n      'case default function var void with const let enum export import native ' +\r\n      '__hasProp __extends __slice __bind __indexOf',\r\n    built_in:\r\n      'npm require console print module exports global window document'\r\n  };\r\n  var JS_IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';\r\n  var TITLE = {className: 'title', begin: JS_IDENT_RE};\r\n  var SUBST = {\r\n    className: 'subst',\r\n    begin: '#\\\\{', end: '}',\r\n    keywords: KEYWORDS,\r\n  };\r\n  var EXPRESSIONS = [\r\n    // Numbers\r\n    hljs.BINARY_NUMBER_MODE,\r\n    hljs.inherit(hljs.C_NUMBER_MODE, {starts: {end: '(\\\\s*/)?', relevance: 0}}), // a number tries to eat the following slash to prevent treating it as a regexp\r\n    // Strings\r\n    {\r\n      className: 'string',\r\n      begin: '\\'\\'\\'', end: '\\'\\'\\'',\r\n      contains: [hljs.BACKSLASH_ESCAPE]\r\n    },\r\n    {\r\n      className: 'string',\r\n      begin: '\\'', end: '\\'',\r\n      contains: [hljs.BACKSLASH_ESCAPE],\r\n      relevance: 0\r\n    },\r\n    {\r\n      className: 'string',\r\n      begin: '\"\"\"', end: '\"\"\"',\r\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST]\r\n    },\r\n    {\r\n      className: 'string',\r\n      begin: '\"', end: '\"',\r\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\r\n      relevance: 0\r\n    },\r\n    // RegExps\r\n    {\r\n      className: 'regexp',\r\n      begin: '///', end: '///',\r\n      contains: [hljs.HASH_COMMENT_MODE]\r\n    },\r\n    {\r\n      className: 'regexp', begin: '//[gim]*',\r\n      relevance: 0\r\n    },\r\n    {\r\n      className: 'regexp',\r\n      begin: '/\\\\S(\\\\\\\\.|[^\\\\n])*?/[gim]*(?=\\\\s|\\\\W|$)' // \\S is required to parse x / 2 / 3 as two divisions\r\n    },\r\n\r\n    {\r\n      className: 'property',\r\n      begin: '@' + JS_IDENT_RE\r\n    },\r\n    {\r\n      begin: '`', end: '`',\r\n      excludeBegin: true, excludeEnd: true,\r\n      subLanguage: 'javascript'\r\n    }\r\n  ];\r\n  SUBST.contains = EXPRESSIONS;\r\n\r\n  return {\r\n    keywords: KEYWORDS,\r\n    contains: EXPRESSIONS.concat([\r\n      {\r\n        className: 'comment',\r\n        begin: '###', end: '###'\r\n      },\r\n      hljs.HASH_COMMENT_MODE,\r\n      {\r\n        className: 'function',\r\n        begin: '(' + JS_IDENT_RE + '\\\\s*=\\\\s*)?(\\\\(.*\\\\))?\\\\s*[-=]>', end: '[-=]>',\r\n        returnBegin: true,\r\n        contains: [\r\n          TITLE,\r\n          {\r\n            className: 'params',\r\n            begin: '\\\\(', returnBegin: true,\r\n            /* We need another contained nameless mode to not have every nested\r\n            pair of parens to be called \"params\" */\r\n            contains: [{\r\n              begin: /\\(/, end: /\\)/,\r\n              keywords: KEYWORDS,\r\n              contains: ['self'].concat(EXPRESSIONS)\r\n            }]\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        className: 'class',\r\n        beginWithKeyword: true, keywords: 'class',\r\n        end: '$',\r\n        illegal: '[:\\\\[\\\\]]',\r\n        contains: [\r\n          {\r\n            beginWithKeyword: true, keywords: 'extends',\r\n            endsWithParent: true,\r\n            illegal: ':',\r\n            contains: [TITLE]\r\n          },\r\n          TITLE\r\n        ]\r\n      },\r\n      {\r\n        className: 'attribute',\r\n        begin: JS_IDENT_RE + ':', end: ':',\r\n        returnBegin: true, excludeEnd: true\r\n      }\r\n    ])\r\n  };\r\n};\n\n// WEBPACK FOOTER\n// module.id = 37\n// module.readableIdentifier = ./lib/highlight.js/coffeescript.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/coffeescript.js")},38:function(module,exports,require){eval("module.exports = function(hljs) {\r\n  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';\r\n  var FUNCTION = {\r\n    className: 'function',\r\n    begin: IDENT_RE + '\\\\(', end: '\\\\)',\r\n    contains: ['self', hljs.NUMBER_MODE, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]\r\n  };\r\n  return {\r\n    case_insensitive: true,\r\n    illegal: '[=/|\\']',\r\n    contains: [\r\n      hljs.C_BLOCK_COMMENT_MODE,\r\n      {\r\n        className: 'id', begin: '\\\\#[A-Za-z0-9_-]+'\r\n      },\r\n      {\r\n        className: 'class', begin: '\\\\.[A-Za-z0-9_-]+',\r\n        relevance: 0\r\n      },\r\n      {\r\n        className: 'attr_selector',\r\n        begin: '\\\\[', end: '\\\\]',\r\n        illegal: '$'\r\n      },\r\n      {\r\n        className: 'pseudo',\r\n        begin: ':(:)?[a-zA-Z0-9\\\\_\\\\-\\\\+\\\\(\\\\)\\\\\"\\\\\\']+'\r\n      },\r\n      {\r\n        className: 'at_rule',\r\n        begin: '@(font-face|page)',\r\n        lexems: '[a-z-]+',\r\n        keywords: 'font-face page'\r\n      },\r\n      {\r\n        className: 'at_rule',\r\n        begin: '@', end: '[{;]', // at_rule eating first \"{\" is a good thing\r\n                                 // because it doesnâ€™t let it to be parsed as\r\n                                 // a rule set but instead drops parser into\r\n                                 // the default mode which is how it should be.\r\n        contains: [\r\n          {\r\n            className: 'keyword',\r\n            begin: /\\S+/\r\n          },\r\n          {\r\n            begin: /\\s/, endsWithParent: true, excludeEnd: true,\r\n            relevance: 0,\r\n            contains: [\r\n              FUNCTION,\r\n              hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE,\r\n              hljs.NUMBER_MODE\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        className: 'tag', begin: IDENT_RE,\r\n        relevance: 0\r\n      },\r\n      {\r\n        className: 'rules',\r\n        begin: '{', end: '}',\r\n        illegal: '[^\\\\s]',\r\n        relevance: 0,\r\n        contains: [\r\n          hljs.C_BLOCK_COMMENT_MODE,\r\n          {\r\n            className: 'rule',\r\n            begin: '[^\\\\s]', returnBegin: true, end: ';', endsWithParent: true,\r\n            contains: [\r\n              {\r\n                className: 'attribute',\r\n                begin: '[A-Z\\\\_\\\\.\\\\-]+', end: ':',\r\n                excludeEnd: true,\r\n                illegal: '[^\\\\s]',\r\n                starts: {\r\n                  className: 'value',\r\n                  endsWithParent: true, excludeEnd: true,\r\n                  contains: [\r\n                    FUNCTION,\r\n                    hljs.NUMBER_MODE,\r\n                    hljs.QUOTE_STRING_MODE,\r\n                    hljs.APOS_STRING_MODE,\r\n                    hljs.C_BLOCK_COMMENT_MODE,\r\n                    {\r\n                      className: 'hexcolor', begin: '#[0-9A-Fa-f]+'\r\n                    },\r\n                    {\r\n                      className: 'important', begin: '!important'\r\n                    }\r\n                  ]\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  };\r\n};\n\n// WEBPACK FOOTER\n// module.id = 38\n// module.readableIdentifier = ./lib/highlight.js/css.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/css.js")},39:function(module,exports,require){eval("var hljs = new function() {\r\n\r\n  /* Utility functions */\r\n\r\n  function escape(value) {\r\n    return value.replace(/&/gm, '&amp;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;');\r\n  }\r\n\r\n  function findCode(pre) {\r\n    for (var node = pre.firstChild; node; node = node.nextSibling) {\r\n      if (node.nodeName.toUpperCase () == 'CODE')\r\n        return node;\r\n      if (!(node.nodeType == 3 && node.nodeValue.match(/\\s+/)))\r\n        break;\r\n    }\r\n  }\r\n\r\n  function blockText(block, ignoreNewLines) {\r\n    return Array.prototype.map.call(block.childNodes, function(node) {\r\n      if (node.nodeType == 3) {\r\n        return ignoreNewLines ? node.nodeValue.replace(/\\n/g, '') : node.nodeValue;\r\n      }\r\n      if (node.nodeName.toUpperCase () == 'BR') {\r\n        return '\\n';\r\n      }\r\n      return blockText(node, ignoreNewLines);\r\n    }).join('');\r\n  }\r\n\r\n  function blockLanguage(block) {\r\n    var classes = (block.className + ' ' + (block.parentNode ? block.parentNode.className : '')).split(/\\s+/);\r\n    classes = classes.map(function(c) {return c.replace(/^language-/, '');});\r\n    for (var i = 0; i < classes.length; i++) {\r\n      if (languages[classes[i]] || classes[i] == 'no-highlight') {\r\n        return classes[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Stream merging */\r\n\r\n  function nodeStream(node) {\r\n    var result = [];\r\n    (function _nodeStream(node, offset) {\r\n      for (var child = node.firstChild; child; child = child.nextSibling) {\r\n        if (child.nodeType == 3)\r\n          offset += child.nodeValue.length;\r\n        else if (child.nodeName.toUpperCase() == 'BR')\r\n          offset += 1;\r\n        else if (child.nodeType == 1) {\r\n          result.push({\r\n            event: 'start',\r\n            offset: offset,\r\n            node: child\r\n          });\r\n          offset = _nodeStream(child, offset);\r\n          result.push({\r\n            event: 'stop',\r\n            offset: offset,\r\n            node: child\r\n          });\r\n        }\r\n      }\r\n      return offset;\r\n    })(node, 0);\r\n    return result;\r\n  }\r\n\r\n  function mergeStreams(original, highlighted, value) {\r\n    var processed = 0;\r\n    var result = '';\r\n    var nodeStack = [];\r\n\r\n    function selectStream() {\r\n      if (!original.length || !highlighted.length) {\r\n        return original.length ? original : highlighted;\r\n      }\r\n      if (original[0].offset != highlighted[0].offset) {\r\n        return (original[0].offset < highlighted[0].offset) ? original : highlighted;\r\n      }\r\n\r\n      /*\r\n      To avoid starting the stream just before it should stop the order is\r\n      ensured that original always starts first and closes last:\r\n\r\n      if (event1 == 'start' && event2 == 'start')\r\n        return original;\r\n      if (event1 == 'start' && event2 == 'stop')\r\n        return highlighted;\r\n      if (event1 == 'stop' && event2 == 'start')\r\n        return original;\r\n      if (event1 == 'stop' && event2 == 'stop')\r\n        return highlighted;\r\n\r\n      ... which is collapsed to:\r\n      */\r\n      return highlighted[0].event == 'start' ? original : highlighted;\r\n    }\r\n\r\n    function open(node) {\r\n      function attr_str(a) {return ' ' + a.nodeName + '=\"' + escape(a.value) + '\"';}\r\n      result += '<' + node.nodeName.toLowerCase() + Array.prototype.map.call(node.attributes, attr_str).join('') + '>';\r\n    }\r\n\r\n    function close(node) {\r\n      result += '</' + node.nodeName.toLowerCase() + '>';\r\n    }\r\n\r\n    function render(event) {\r\n      (event.event == 'start' ? open : close)(event.node);\r\n    }\r\n\r\n    while (original.length || highlighted.length) {\r\n      var stream = selectStream();\r\n      result += escape(value.substr(processed, stream[0].offset - processed));\r\n      processed = stream[0].offset;\r\n      if (stream == original) {\r\n        /*\r\n        On any opening or closing tag of the original markup we first close\r\n        the entire highlighted node stack, then render the original tag along\r\n        with all the following original tags at the same offset and then\r\n        reopen all the tags on the highlighted stack.\r\n        */\r\n        nodeStack.reverse().forEach(close);\r\n        do {\r\n          render(stream.splice(0, 1)[0]);\r\n          stream = selectStream();\r\n        } while (stream == original && stream.length && stream[0].offset == processed);\r\n        nodeStack.reverse().forEach(open);\r\n      } else {\r\n        if (stream[0].event == 'start') {\r\n          nodeStack.push(stream[0].node);\r\n        } else {\r\n          nodeStack.pop();\r\n        }\r\n        render(stream.splice(0, 1)[0]);\r\n      }\r\n    }\r\n    return result + escape(value.substr(processed));\r\n  }\r\n\r\n  /* Initialization */\r\n\r\n  function compileLanguage(language) {\r\n\r\n    function reStr(re) {\r\n        return (re && re.source) || re;\r\n    }\r\n\r\n    function langRe(value, global) {\r\n      return RegExp(\r\n        reStr(value),\r\n        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\r\n      );\r\n    }\r\n\r\n    function compileMode(mode, parent) {\r\n      if (mode.compiled)\r\n        return;\r\n      mode.compiled = true;\r\n\r\n      var keywords = []; // used later with beginWithKeyword but filled as a side-effect of keywords compilation\r\n      if (mode.keywords) {\r\n        var compiled_keywords = {};\r\n\r\n        function flatten(className, str) {\r\n          if (language.case_insensitive) {\r\n            str = str.toLowerCase();\r\n          }\r\n          str.split(' ').forEach(function(kw) {\r\n            var pair = kw.split('|');\r\n            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\r\n            keywords.push(pair[0]);\r\n          });\r\n        }\r\n\r\n        mode.lexemsRe = langRe(mode.lexems || '\\\\b' + hljs.IDENT_RE + '\\\\b(?!\\\\.)', true);\r\n        if (typeof mode.keywords == 'string') { // string\r\n          flatten('keyword', mode.keywords);\r\n        } else {\r\n          for (var className in mode.keywords) {\r\n            if (!mode.keywords.hasOwnProperty(className))\r\n              continue;\r\n            flatten(className, mode.keywords[className]);\r\n          }\r\n        }\r\n        mode.keywords = compiled_keywords;\r\n      }\r\n      if (parent) {\r\n        if (mode.beginWithKeyword) {\r\n          mode.begin = '\\\\b(' + keywords.join('|') + ')\\\\b(?!\\\\.)\\\\s*';\r\n        }\r\n        mode.beginRe = langRe(mode.begin ? mode.begin : '\\\\B|\\\\b');\r\n        if (!mode.end && !mode.endsWithParent)\r\n          mode.end = '\\\\B|\\\\b';\r\n        if (mode.end)\r\n          mode.endRe = langRe(mode.end);\r\n        mode.terminator_end = reStr(mode.end) || '';\r\n        if (mode.endsWithParent && parent.terminator_end)\r\n          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;\r\n      }\r\n      if (mode.illegal)\r\n        mode.illegalRe = langRe(mode.illegal);\r\n      if (mode.relevance === undefined)\r\n        mode.relevance = 1;\r\n      if (!mode.contains) {\r\n        mode.contains = [];\r\n      }\r\n      for (var i = 0; i < mode.contains.length; i++) {\r\n        if (mode.contains[i] == 'self') {\r\n          mode.contains[i] = mode;\r\n        }\r\n        compileMode(mode.contains[i], mode);\r\n      }\r\n      if (mode.starts) {\r\n        compileMode(mode.starts, parent);\r\n      }\r\n\r\n      var terminators = [];\r\n      for (var i = 0; i < mode.contains.length; i++) {\r\n        terminators.push(reStr(mode.contains[i].begin));\r\n      }\r\n      if (mode.terminator_end) {\r\n        terminators.push(reStr(mode.terminator_end));\r\n      }\r\n      if (mode.illegal) {\r\n        terminators.push(reStr(mode.illegal));\r\n      }\r\n      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(s) {return null;}};\r\n    }\r\n\r\n    compileMode(language);\r\n  }\r\n\r\n  /*\r\n  Core highlighting function. Accepts a language name and a string with the\r\n  code to highlight. Returns an object with the following properties:\r\n\r\n  - relevance (int)\r\n  - keyword_count (int)\r\n  - value (an HTML string with highlighting markup)\r\n\r\n  */\r\n  function highlight(language_name, value, ignore_illegals, continuation) {\r\n\r\n    function subMode(lexem, mode) {\r\n      for (var i = 0; i < mode.contains.length; i++) {\r\n        var match = mode.contains[i].beginRe.exec(lexem);\r\n        if (match && match.index == 0) {\r\n          return mode.contains[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    function endOfMode(mode, lexem) {\r\n      if (mode.end && mode.endRe.test(lexem)) {\r\n        return mode;\r\n      }\r\n      if (mode.endsWithParent) {\r\n        return endOfMode(mode.parent, lexem);\r\n      }\r\n    }\r\n\r\n    function isIllegal(lexem, mode) {\r\n      return !ignore_illegals && mode.illegal && mode.illegalRe.test(lexem);\r\n    }\r\n\r\n    function keywordMatch(mode, match) {\r\n      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];\r\n      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];\r\n    }\r\n\r\n    function processKeywords() {\r\n      var buffer = escape(mode_buffer);\r\n      if (!top.keywords)\r\n        return buffer;\r\n      var result = '';\r\n      var last_index = 0;\r\n      top.lexemsRe.lastIndex = 0;\r\n      var match = top.lexemsRe.exec(buffer);\r\n      while (match) {\r\n        result += buffer.substr(last_index, match.index - last_index);\r\n        var keyword_match = keywordMatch(top, match);\r\n        if (keyword_match) {\r\n          keyword_count += keyword_match[1];\r\n          result += '<span class=\"'+ keyword_match[0] +'\">' + match[0] + '</span>';\r\n        } else {\r\n          result += match[0];\r\n        }\r\n        last_index = top.lexemsRe.lastIndex;\r\n        match = top.lexemsRe.exec(buffer);\r\n      }\r\n      return result + buffer.substr(last_index);\r\n    }\r\n\r\n    function processSubLanguage() {\r\n      if (top.subLanguage && !languages[top.subLanguage]) {\r\n        return escape(mode_buffer);\r\n      }\r\n      var continuation = top.subLanguageMode == 'continuous' ? top.top : undefined;\r\n      var result = top.subLanguage ? highlight(top.subLanguage, mode_buffer, true, continuation) : highlightAuto(mode_buffer);\r\n      // Counting embedded language score towards the host language may be disabled\r\n      // with zeroing the containing mode relevance. Usecase in point is Markdown that\r\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\r\n      // score.\r\n      if (top.relevance > 0) {\r\n        keyword_count += result.keyword_count;\r\n        relevance += result.relevance;\r\n      }\r\n      top.top = result.top;\r\n      return '<span class=\"' + result.language  + '\">' + result.value + '</span>';\r\n    }\r\n\r\n    function processBuffer() {\r\n      return top.subLanguage !== undefined ? processSubLanguage() : processKeywords();\r\n    }\r\n\r\n    function startNewMode(mode, lexem) {\r\n      var markup = mode.className? '<span class=\"' + mode.className + '\">': '';\r\n      if (mode.returnBegin) {\r\n        result += markup;\r\n        mode_buffer = '';\r\n      } else if (mode.excludeBegin) {\r\n        result += escape(lexem) + markup;\r\n        mode_buffer = '';\r\n      } else {\r\n        result += markup;\r\n        mode_buffer = lexem;\r\n      }\r\n      top = Object.create(mode, {parent: {value: top}});\r\n    }\r\n\r\n    function processLexem(buffer, lexem) {\r\n      mode_buffer += buffer;\r\n      if (lexem === undefined) {\r\n        result += processBuffer();\r\n        return 0;\r\n      }\r\n\r\n      var new_mode = subMode(lexem, top);\r\n      if (new_mode) {\r\n        result += processBuffer();\r\n        startNewMode(new_mode, lexem);\r\n        return new_mode.returnBegin ? 0 : lexem.length;\r\n      }\r\n\r\n      var end_mode = endOfMode(top, lexem);\r\n      if (end_mode) {\r\n        var origin = top;\r\n        if (!(origin.returnEnd || origin.excludeEnd)) {\r\n          mode_buffer += lexem;\r\n        }\r\n        result += processBuffer();\r\n        do {\r\n          if (top.className) {\r\n            result += '</span>';\r\n          }\r\n          relevance += top.relevance;\r\n          top = top.parent;\r\n        } while (top != end_mode.parent);\r\n        if (origin.excludeEnd) {\r\n          result += escape(lexem);\r\n        }\r\n        mode_buffer = '';\r\n        if (end_mode.starts) {\r\n          startNewMode(end_mode.starts, '');\r\n        }\r\n        return origin.returnEnd ? 0 : lexem.length;\r\n      }\r\n\r\n      if (isIllegal(lexem, top))\r\n        throw new Error('Illegal lexem \"' + lexem + '\" for mode \"' + (top.className || '<unnamed>') + '\"');\r\n\r\n      /*\r\n      Parser should not reach this point as all types of lexems should be caught\r\n      earlier, but if it does due to some bug make sure it advances at least one\r\n      character forward to prevent infinite looping.\r\n      */\r\n      mode_buffer += lexem;\r\n      return lexem.length || 1;\r\n    }\r\n\r\n    var language = languages[language_name];\r\n    if (!language) {\r\n      throw new Error('Unknown language: \"' + language_name + '\"');\r\n    }\r\n\r\n    compileLanguage(language);\r\n    var top = continuation || language;\r\n    var result = '';\r\n    for(var current = top; current != language; current = current.parent) {\r\n      if (current.className) {\r\n        result = '<span class=\"' + current.className +'\">' + result;\r\n      }\r\n    }\r\n    var mode_buffer = '';\r\n    var relevance = 0;\r\n    var keyword_count = 0;\r\n    try {\r\n      var match, count, index = 0;\r\n      while (true) {\r\n        top.terminators.lastIndex = index;\r\n        match = top.terminators.exec(value);\r\n        if (!match)\r\n          break;\r\n        count = processLexem(value.substr(index, match.index - index), match[0]);\r\n        index = match.index + count;\r\n      }\r\n      processLexem(value.substr(index));\r\n      for(var current = top; current.parent; current = current.parent) { // close dangling modes\r\n        if (current.className) {\r\n          result += '</span>';\r\n        }\r\n      };\r\n      return {\r\n        relevance: relevance,\r\n        keyword_count: keyword_count,\r\n        value: result,\r\n        language: language_name,\r\n        top: top\r\n      };\r\n    } catch (e) {\r\n      if (e.message.indexOf('Illegal') != -1) {\r\n        return {\r\n          relevance: 0,\r\n          keyword_count: 0,\r\n          value: escape(value)\r\n        };\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  Highlighting with language detection. Accepts a string with the code to\r\n  highlight. Returns an object with the following properties:\r\n\r\n  - language (detected language)\r\n  - relevance (int)\r\n  - keyword_count (int)\r\n  - value (an HTML string with highlighting markup)\r\n  - second_best (object with the same structure for second-best heuristically\r\n    detected language, may be absent)\r\n\r\n  */\r\n  function highlightAuto(text) {\r\n    var result = {\r\n      keyword_count: 0,\r\n      relevance: 0,\r\n      value: escape(text)\r\n    };\r\n    var second_best = result;\r\n    for (var key in languages) {\r\n      if (!languages.hasOwnProperty(key))\r\n        continue;\r\n      var current = highlight(key, text, false);\r\n      current.language = key;\r\n      if (current.keyword_count + current.relevance > second_best.keyword_count + second_best.relevance) {\r\n        second_best = current;\r\n      }\r\n      if (current.keyword_count + current.relevance > result.keyword_count + result.relevance) {\r\n        second_best = result;\r\n        result = current;\r\n      }\r\n    }\r\n    if (second_best.language) {\r\n      result.second_best = second_best;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /*\r\n  Post-processing of the highlighted markup:\r\n\r\n  - replace TABs with something more useful\r\n  - replace real line-breaks with '<br>' for non-pre containers\r\n\r\n  */\r\n  function fixMarkup(value, tabReplace, useBR) {\r\n    if (tabReplace) {\r\n      value = value.replace(/^((<[^>]+>|\\t)+)/gm, function(match, p1, offset, s) {\r\n        return p1.replace(/\\t/g, tabReplace);\r\n      });\r\n    }\r\n    if (useBR) {\r\n      value = value.replace(/\\n/g, '<br>');\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /*\r\n  Applies highlighting to a DOM node containing code. Accepts a DOM node and\r\n  two optional parameters for fixMarkup.\r\n  */\r\n  function highlightBlock(block, tabReplace, useBR) {\r\n    var text = blockText(block, useBR);\r\n    var language = blockLanguage(block);\r\n    if (language == 'no-highlight')\r\n        return;\r\n    var result = language ? highlight(language, text, true) : highlightAuto(text);\r\n    language = result.language;\r\n    var original = nodeStream(block);\r\n    if (original.length) {\r\n      var pre = document.createElementNS('http://www.w3.org/1999/xhtml', 'pre');\r\n      pre.innerHTML = result.value;\r\n      result.value = mergeStreams(original, nodeStream(pre), text);\r\n    }\r\n    result.value = fixMarkup(result.value, tabReplace, useBR);\r\n\r\n    var class_name = block.className;\r\n    if (!class_name.match('(\\\\s|^)(language-)?' + language + '(\\\\s|$)')) {\r\n      class_name = class_name ? (class_name + ' ' + language) : language;\r\n    }\r\n    block.innerHTML = result.value;\r\n    block.className = class_name;\r\n    block.result = {\r\n      language: language,\r\n      kw: result.keyword_count,\r\n      re: result.relevance\r\n    };\r\n    if (result.second_best) {\r\n      block.second_best = {\r\n        language: result.second_best.language,\r\n        kw: result.second_best.keyword_count,\r\n        re: result.second_best.relevance\r\n      };\r\n    }\r\n  }\r\n\r\n  /*\r\n  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\r\n  */\r\n  function initHighlighting() {\r\n    if (initHighlighting.called)\r\n      return;\r\n    initHighlighting.called = true;\r\n    Array.prototype.map.call(document.getElementsByTagNameNS('http://www.w3.org/1999/xhtml', 'pre'), findCode).\r\n      filter(Boolean).\r\n      forEach(function(code){highlightBlock(code, hljs.tabReplace);});\r\n  }\r\n\r\n  /*\r\n  Attaches highlighting to the page load event.\r\n  */\r\n  function initHighlightingOnLoad() {\r\n    window.addEventListener('DOMContentLoaded', initHighlighting, false);\r\n    window.addEventListener('load', initHighlighting, false);\r\n  }\r\n\r\n  var languages = {}; // a shortcut to avoid writing \"this.\" everywhere\r\n\r\n  /* Interface definition */\r\n\r\n  this.LANGUAGES = languages;\r\n  this.highlight = highlight;\r\n  this.highlightAuto = highlightAuto;\r\n  this.fixMarkup = fixMarkup;\r\n  this.highlightBlock = highlightBlock;\r\n  this.initHighlighting = initHighlighting;\r\n  this.initHighlightingOnLoad = initHighlightingOnLoad;\r\n\r\n  // Common regexps\r\n  this.IDENT_RE = '[a-zA-Z][a-zA-Z0-9_]*';\r\n  this.UNDERSCORE_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*';\r\n  this.NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\r\n  this.C_NUMBER_RE = '(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\r\n  this.BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\r\n  this.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|\\\\.|-|-=|/|/=|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\r\n\r\n  // Common modes\r\n  this.BACKSLASH_ESCAPE = {\r\n    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\r\n  };\r\n  this.APOS_STRING_MODE = {\r\n    className: 'string',\r\n    begin: '\\'', end: '\\'',\r\n    illegal: '\\\\n',\r\n    contains: [this.BACKSLASH_ESCAPE],\r\n    relevance: 0\r\n  };\r\n  this.QUOTE_STRING_MODE = {\r\n    className: 'string',\r\n    begin: '\"', end: '\"',\r\n    illegal: '\\\\n',\r\n    contains: [this.BACKSLASH_ESCAPE],\r\n    relevance: 0\r\n  };\r\n  this.C_LINE_COMMENT_MODE = {\r\n    className: 'comment',\r\n    begin: '//', end: '$'\r\n  };\r\n  this.C_BLOCK_COMMENT_MODE = {\r\n    className: 'comment',\r\n    begin: '/\\\\*', end: '\\\\*/'\r\n  };\r\n  this.HASH_COMMENT_MODE = {\r\n    className: 'comment',\r\n    begin: '#', end: '$'\r\n  };\r\n  this.NUMBER_MODE = {\r\n    className: 'number',\r\n    begin: this.NUMBER_RE,\r\n    relevance: 0\r\n  };\r\n  this.C_NUMBER_MODE = {\r\n    className: 'number',\r\n    begin: this.C_NUMBER_RE,\r\n    relevance: 0\r\n  };\r\n  this.BINARY_NUMBER_MODE = {\r\n    className: 'number',\r\n    begin: this.BINARY_NUMBER_RE,\r\n    relevance: 0\r\n  };\r\n  this.REGEXP_MODE = {\r\n    className: 'regexp',\r\n    begin: /\\//, end: /\\/[gim]*/,\r\n    illegal: /\\n/,\r\n    contains: [\r\n      this.BACKSLASH_ESCAPE,\r\n      {\r\n        begin: /\\[/, end: /\\]/,\r\n        relevance: 0,\r\n        contains: [this.BACKSLASH_ESCAPE]\r\n      }\r\n    ]\r\n  };\r\n\r\n  // Utility functions\r\n  this.inherit = function(parent, obj) {\r\n    var result = {};\r\n    for (var key in parent)\r\n      result[key] = parent[key];\r\n    if (obj)\r\n      for (var key in obj)\r\n        result[key] = obj[key];\r\n    return result;\r\n  };\r\n}();\r\nhljs.LANGUAGES['coffeescript'] = require(37)(hljs);\r\nhljs.LANGUAGES['css'] = require(38)(hljs);\r\nhljs.LANGUAGES['javascript'] = require(40)(hljs);\r\nhljs.LANGUAGES['json'] = require(41)(hljs);\r\nhljs.LANGUAGES['xml'] = require(42)(hljs);\r\nmodule.exports = hljs;\n\n// WEBPACK FOOTER\n// module.id = 39\n// module.readableIdentifier = ./lib/highlight.js/highlight.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/highlight.js")
},40:function(module,exports,require){eval("module.exports = function(hljs) {\r\n  return {\r\n    keywords: {\r\n      keyword:\r\n        'in if for while finally var new function do return void else break catch ' +\r\n        'instanceof with throw case default try this switch continue typeof delete ' +\r\n        'let yield const',\r\n      literal:\r\n        'true false null undefined NaN Infinity'\r\n    },\r\n    contains: [\r\n      hljs.APOS_STRING_MODE,\r\n      hljs.QUOTE_STRING_MODE,\r\n      hljs.C_LINE_COMMENT_MODE,\r\n      hljs.C_BLOCK_COMMENT_MODE,\r\n      hljs.C_NUMBER_MODE,\r\n      { // \"value\" container\r\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\r\n        keywords: 'return throw case',\r\n        contains: [\r\n          hljs.C_LINE_COMMENT_MODE,\r\n          hljs.C_BLOCK_COMMENT_MODE,\r\n          hljs.REGEXP_MODE,\r\n          { // E4X\r\n            begin: /</, end: />;/,\r\n            subLanguage: 'xml'\r\n          }\r\n        ],\r\n        relevance: 0\r\n      },\r\n      {\r\n        className: 'function',\r\n        beginWithKeyword: true, end: /{/,\r\n        keywords: 'function',\r\n        contains: [\r\n          {\r\n            className: 'title', begin: /[A-Za-z$_][0-9A-Za-z$_]*/\r\n          },\r\n          {\r\n            className: 'params',\r\n            begin: /\\(/, end: /\\)/,\r\n            contains: [\r\n              hljs.C_LINE_COMMENT_MODE,\r\n              hljs.C_BLOCK_COMMENT_MODE\r\n            ],\r\n            illegal: /[\"'\\(]/\r\n          }\r\n        ],\r\n        illegal: /\\[|%/\r\n      }\r\n    ]\r\n  };\r\n};\n\n// WEBPACK FOOTER\n// module.id = 40\n// module.readableIdentifier = ./lib/highlight.js/javascript.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/javascript.js")},41:function(module,exports,require){eval("module.exports = function(hljs) {\r\n  var LITERALS = {literal: 'true false null'};\r\n  var TYPES = [\r\n    hljs.QUOTE_STRING_MODE,\r\n    hljs.C_NUMBER_MODE\r\n  ];\r\n  var VALUE_CONTAINER = {\r\n    className: 'value',\r\n    end: ',', endsWithParent: true, excludeEnd: true,\r\n    contains: TYPES,\r\n    keywords: LITERALS\r\n  };\r\n  var OBJECT = {\r\n    begin: '{', end: '}',\r\n    contains: [\r\n      {\r\n        className: 'attribute',\r\n        begin: '\\\\s*\"', end: '\"\\\\s*:\\\\s*', excludeBegin: true, excludeEnd: true,\r\n        contains: [hljs.BACKSLASH_ESCAPE],\r\n        illegal: '\\\\n',\r\n        starts: VALUE_CONTAINER\r\n      }\r\n    ],\r\n    illegal: '\\\\S'\r\n  };\r\n  var ARRAY = {\r\n    begin: '\\\\[', end: '\\\\]',\r\n    contains: [hljs.inherit(VALUE_CONTAINER, {className: null})], // inherit is also a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents\r\n    illegal: '\\\\S'\r\n  };\r\n  TYPES.splice(TYPES.length, 0, OBJECT, ARRAY);\r\n  return {\r\n    contains: TYPES,\r\n    keywords: LITERALS,\r\n    illegal: '\\\\S'\r\n  };\r\n};\n\n// WEBPACK FOOTER\n// module.id = 41\n// module.readableIdentifier = ./lib/highlight.js/json.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/json.js")},42:function(module,exports,require){eval("module.exports = function(hljs) {\r\n  var XML_IDENT_RE = '[A-Za-z0-9\\\\._:-]+';\r\n  var TAG_INTERNALS = {\r\n    endsWithParent: true,\r\n    relevance: 0,\r\n    contains: [\r\n      {\r\n        className: 'attribute',\r\n        begin: XML_IDENT_RE,\r\n        relevance: 0\r\n      },\r\n      {\r\n        begin: '=\"', returnBegin: true, end: '\"',\r\n        contains: [{\r\n            className: 'value',\r\n            begin: '\"', endsWithParent: true\r\n        }]\r\n      },\r\n      {\r\n        begin: '=\\'', returnBegin: true, end: '\\'',\r\n        contains: [{\r\n          className: 'value',\r\n          begin: '\\'', endsWithParent: true\r\n        }]\r\n      },\r\n      {\r\n        begin: '=',\r\n        contains: [{\r\n          className: 'value',\r\n          begin: '[^\\\\s/>]+'\r\n        }]\r\n      }\r\n    ]\r\n  };\r\n  return {\r\n    case_insensitive: true,\r\n    contains: [\r\n      {\r\n        className: 'pi',\r\n        begin: '<\\\\?', end: '\\\\?>',\r\n        relevance: 10\r\n      },\r\n      {\r\n        className: 'doctype',\r\n        begin: '<!DOCTYPE', end: '>',\r\n        relevance: 10,\r\n        contains: [{begin: '\\\\[', end: '\\\\]'}]\r\n      },\r\n      {\r\n        className: 'comment',\r\n        begin: '<!--', end: '-->',\r\n        relevance: 10\r\n      },\r\n      {\r\n        className: 'cdata',\r\n        begin: '<\\\\!\\\\[CDATA\\\\[', end: '\\\\]\\\\]>',\r\n        relevance: 10\r\n      },\r\n      {\r\n        className: 'tag',\r\n        /*\r\n        The lookahead pattern (?=...) ensures that 'begin' only matches\r\n        '<style' as a single word, followed by a whitespace or an\r\n        ending braket. The '$' is needed for the lexem to be recognized\r\n        by hljs.subMode() that tests lexems outside the stream.\r\n        */\r\n        begin: '<style(?=\\\\s|>|$)', end: '>',\r\n        keywords: {title: 'style'},\r\n        contains: [TAG_INTERNALS],\r\n        starts: {\r\n          end: '</style>', returnEnd: true,\r\n          subLanguage: 'css'\r\n        }\r\n      },\r\n      {\r\n        className: 'tag',\r\n        // See the comment in the <style tag about the lookahead pattern\r\n        begin: '<script(?=\\\\s|>|$)', end: '>',\r\n        keywords: {title: 'script'},\r\n        contains: [TAG_INTERNALS],\r\n        starts: {\r\n          end: '</script>', returnEnd: true,\r\n          subLanguage: 'javascript'\r\n        }\r\n      },\r\n      {\r\n        begin: '<%', end: '%>',\r\n        subLanguage: 'vbscript'\r\n      },\r\n      {\r\n        className: 'tag',\r\n        begin: '</?', end: '/?>',\r\n        relevance: 0,\r\n        contains: [\r\n          {\r\n            className: 'title', begin: '[^ /><]+'\r\n          },\r\n          TAG_INTERNALS\r\n        ]\r\n      }\r\n    ]\r\n  };\r\n};\n\n// WEBPACK FOOTER\n// module.id = 42\n// module.readableIdentifier = ./lib/highlight.js/xml.js\n//@ sourceURL=webpack-module:///./lib/highlight.js/xml.js")},44:function(module,exports,require){eval("/* WEBPACK VAR INJECTION */(function(require, global) {/**\n * marked - a markdown parser\n * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment|closed|closing) *(?:\\n{2,}|\\s*$)/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', /\\n+(?=(?: *[-*_]){3,} *(?:\\n+|$))/)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3]\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if (top && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (cap = this.rules.url.exec(src)) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? escape(cap[0])\n        : cap[0];\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      out += this.outputLink(cap, link);\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += escape(this.smartypants(cap[0]));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/--/g, '\\u2014')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer() {}\n\nRenderer.prototype.code = function(code, lang, escaped, options) {\n  options = options || {};\n\n  if (options.highlight) {\n    var out = options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + options.langPrefix\n    + lang\n    + '\">'\n    + (escaped ? code : escape(code))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw, options) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>';\n  return out;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text,\n        this.options\n      );\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped,\n        this.options);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function() {\n      var out, err;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (true) {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, require, (function() { return this; }())))\n\n// WEBPACK FOOTER\n// module.id = 44\n// module.readableIdentifier = ./~/marked/lib/marked.js\n//@ sourceURL=webpack-module:///./~/marked/lib/marked.js")
}});